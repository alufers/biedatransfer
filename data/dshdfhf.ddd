package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/c2h5oh/datasize"
	"github.com/davecgh/go-spew/spew"
	"github.com/gin-gonic/gin"
	magic "github.com/hosom/gomagic"
	"github.com/spf13/viper"
)

func main() {
	viper.SetDefault("http.addr", ":8080")
	viper.SetDefault("http.url", "https://localhost:8080")
	viper.SetDefault("upload.dataDir", "./data")
	viper.SetDefault("upload.forbiddenNames", []string{
		"index.html",
		"index.htm",
		"robots.txt",
		"humans.txt",
		"favicon.ico",
		"wp-admin.php",
		"xmlrpc.php",
		".env",
		".git",
		".config",
		"recents.json",
		".",
		"/",
		"./",
		"style.css",
	})
	viper.SetEnvPrefix("biedatransfer")
	viper.SetConfigName("biedatransfer") // name of config file (without extension)
	viper.SetConfigType("yaml")
	viper.AddConfigPath(".")    // optionally look for config in the working directory
	err := viper.ReadInConfig() // Find and read the config file
	if err != nil {             // Handle errors reading the config file
		log.Printf("failed to read config file: %v", err)
	}
	r := gin.Default()
	r.LoadHTMLGlob("web/*.html")
	r.GET("/", func(c *gin.Context) {
		c.HTML(200, "index.html", map[string]interface{}{
			"URL": viper.GetString("http.url"),
		})
	})
	r.GET("/favicon.ico", func(c *gin.Context) {
		c.File("web/favicon.ico")
	})
	r.GET("/style.css", func(c *gin.Context) {
		c.File("web/style.css")
	})
	r.NoRoute(func(c *gin.Context) {
		spew.Dump(c.Request.Header)

		if c.Request.Method == "PUT" {
			handleUpload(c)
			return
		}
		sendError(c, 404, "Not found!")
	})
	r.Run(viper.GetString("http.addr"))

}

func handleUpload(c *gin.Context) {
	cleanedPath := CleanPath(c.Request.URL.Path)
	forbiddenNames := viper.GetStringSlice("upload.forbiddenNames")
	for _, n := range forbiddenNames {
		lowercase := strings.ToLower(cleanedPath)
		if n == lowercase || "/"+n == lowercase {
			sendError(c, 400, "Forbidden filename!")
			return
		}
	}
	writePath := filepath.Join(viper.GetString("upload.dataDir"), cleanedPath)
	dirPath := filepath.Dir(writePath)
	os.MkdirAll(dirPath, 0777)
	f, err := os.Create(writePath)
	defer f.Close()
	if err != nil {
		sendError(c, 500, fmt.Sprintf("failed to create file %v: %v", cleanedPath, err))
	}
	fileSize, err := io.Copy(f, c.Request.Body)
	if err != nil {
		sendError(c, 500, fmt.Sprintf("failed to copy` file %v: %v", cleanedPath, err))
	}
	m, err := magic.Open(magic.MAGIC_NONE)
	if err != nil {
		log.Fatal(err)
	}
	result, err := m.File(writePath)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(result)
	sendWithFormat(c, 201, map[string]interface{}{
		"url":       viper.GetString("http.url") + cleanedPath,
		"sizeExact": fileSize,
		"size":      datasize.ByteSize(fileSize).HR(),
		"message":   fmt.Sprintf("File %v uploaded!", cleanedPath),
	})
}
